/*
 --問題--
 英小文字からなる長さNの文字列S
 Sのi文字目をsiとする
 Sから0個以上の文字を取り出す方法は2^N通りあるが
 ・取り出した文字を順番を変えずに結合してできた文字列がatcoderとなる
 という条件を満たすものが何通りかを、答えを1000000007で割ったあまりを出力せよ。
 
 --入力--
 N
 S
 
 --入力例--
 10
 attcordeer
 
 --出力--
 4
 
 --出力の解説--
 部分列がatcoderとなる例として、Sの(1,2,4,5,7,8,10)番目の結合がある。
 その他にも方法が3通りあるため、出力は4
 
 --制約--
 ・1<=N<=100000
 ・|S|=N
 ・文字列Sは英小文字のみからなる
 
 --解法--
 a,t,c,o,d,e,rの位置を全探索する=O(|S|^7):TLE
 動的計画法(DP)を考える
 dp[pos][atcoderの何文字目まで] = 通り数
 
 遷移は以下の通り
 ・i+1文字目を選ぶ場合：dp[i+1][j+1] += dp[i][j]　表では右下への加算の動き
 ・i+1文字目を選ばない場合：dp[i+1][j] += dp[i][j]　表では右への現状維持の動き
 これで答えが出るというから不思議：「動的計画法」要チェック
 
   0 1 2 3 4 5 6 7 8 9 10
   a t t c o d e r e r -
 0 1 1 1 1 1 1 1 1 1 1 1
 1 0 1 1 1 1 1 1 1 1 1 1
 2 0 0 1 2 2 2 2 2 2 2 2
 3 0 0 0 0 2 2 2 2 2 2 2
 4 0 0 0 0 0 2 2 2 2 2 2
 5 0 0 0 0 0 0 2 2 2 2 2
 6 0 0 0 0 0 0 0 2 2 4 4
 7 0 0 0 0 0 0 0 0 2 2 6
 
 */

#include <iostream>
using namespace std;

string S;
long long mod = 1000000007;
long long dp[100009][8];

int main() {
    //入力
    int N;
    cin >> N;
    cin >> S;
    
    //動的計画法(Dynamic Programming)
    dp[0][0] = 1;
    for (int i = 0; i < (int)S.size(); i++) {
        for (int j = 0; j <= 7; j++) {
            dp[i + 1][j] += dp[i][j];
            if (S[i] == 'a' && j == 0) dp[i + 1][j + 1] += dp[i][j];
            if (S[i] == 't' && j == 1) dp[i + 1][j + 1] += dp[i][j];
            if (S[i] == 'c' && j == 2) dp[i + 1][j + 1] += dp[i][j];
            if (S[i] == 'o' && j == 3) dp[i + 1][j + 1] += dp[i][j];
            if (S[i] == 'd' && j == 4) dp[i + 1][j + 1] += dp[i][j];
            if (S[i] == 'e' && j == 5) dp[i + 1][j + 1] += dp[i][j];
            if (S[i] == 'r' && j == 6) dp[i + 1][j + 1] += dp[i][j];
        }
        for (int j = 0; j <= 7; j++) dp[i + 1][j] %= mod;
    }
    
    //出力
    cout << dp[S.size()][7] << endl;
    return 0;
}




